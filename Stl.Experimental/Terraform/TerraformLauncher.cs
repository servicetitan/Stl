using System.Linq;
using System.Runtime;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using CliWrap.Models;
using Stl.CommandLine;
using Stl.ParametersSerializer;
using Stl.Terraform.Parameters;

namespace Stl.Terraform
{
    public class TerraformLauncher
    {
        // AY: Shell is just an example of a tool. It could be used like this,
        // though for Terraform I was thinking more of a scenario when you inherit
        // TerraformLauncher from Cmd. 
        private readonly Shell shell;
        private readonly string toolPath;
        private readonly IParameterSerializer parameterSerializer;

        public TerraformLauncher(Shell? shell = null, string? toolPath = null, IParameterSerializer parameterSerializer = null)
        {
            this.shell = shell ?? new Shell();
            //todo: fill path to Terraform 
            this.toolPath = toolPath ?? "";
            this.parameterSerializer = parameterSerializer ?? new ParameterSerializer();
        }

        /// <summary>  
        /// The terraform apply command is used to apply the changes required to reach the desired state of the
        /// configuration, or the pre-determined set of actions generated by a terraform plan execution plan.  
        /// </summary>
        public Task<ExecutionResult> ApplyAsync(ApplyParameters parameters, CmdPart dirOrPlan, CancellationToken token = default) =>
            ExecuteAsync(parameters, dirOrPlan, token);

        public Task<ExecutionResult> FmtAsync(ApplyParameters parameters, CmdPart dirOrPlan, CancellationToken token = default) =>
            ExecuteAsync(parameters, dirOrPlan, token);

        private Task<ExecutionResult> ExecuteAsync(IParameters parameters, CmdPart dirOrPlan, CancellationToken token) =>
            shell.RunAsync(
                toolPath + " " + 
                string.Join(" ", parameterSerializer.Serialize(parameters).Concat(new[] {dirOrPlan}))
                , token);
    }
}
